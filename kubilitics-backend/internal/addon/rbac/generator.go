package rbac

import (
	"fmt"
	"strings"

	"github.com/kubilitics/kubilitics-backend/internal/models"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"sigs.k8s.io/yaml"
)

const rbacHeaderFmt = "# Generated by Kubilitics RSL for %s â€” apply with: kubectl apply -f\n"

func GenerateMinimalRBAC(addon *models.AddOnDetail, releaseName, namespace string) (clusterRoleYAML string, bindingYAML string, err error) {
	if addon == nil {
		return "", "", fmt.Errorf("addon is required")
	}
	if strings.TrimSpace(releaseName) == "" {
		return "", "", fmt.Errorf("releaseName is required")
	}
	if strings.TrimSpace(namespace) == "" {
		return "", "", fmt.Errorf("namespace is required")
	}
	header := fmt.Sprintf(rbacHeaderFmt, addon.Name)

	clusterRules := make([]rbacv1.PolicyRule, 0)
	namespaceRules := make([]rbacv1.PolicyRule, 0)
	for i := range addon.RBACRequired {
		rule := rbacv1.PolicyRule{
			APIGroups: addon.RBACRequired[i].APIGroups,
			Resources: addon.RBACRequired[i].Resources,
			Verbs:     addon.RBACRequired[i].Verbs,
		}
		if addon.RBACRequired[i].Scope == string(models.ScopeCluster) {
			clusterRules = append(clusterRules, rule)
		} else {
			namespaceRules = append(namespaceRules, rule)
		}
	}

	roleName := fmt.Sprintf("kubilitics-%s", releaseName)
	serviceAccountSubject := rbacv1.Subject{
		Kind:      "ServiceAccount",
		Name:      releaseName,
		Namespace: namespace,
	}

	var manifests []string
	if len(clusterRules) > 0 {
		clusterRole := rbacv1.ClusterRole{
			TypeMeta: metav1.TypeMeta{
				Kind:       "ClusterRole",
				APIVersion: "rbac.authorization.k8s.io/v1",
			},
			ObjectMeta: metav1.ObjectMeta{Name: roleName},
			Rules:      clusterRules,
		}
		clusterRoleYAMLBytes, marshalErr := yaml.Marshal(clusterRole)
		if marshalErr != nil {
			return "", "", fmt.Errorf("marshal cluster role: %w", marshalErr)
		}
		clusterRoleYAML = header + string(clusterRoleYAMLBytes)
		clusterRoleBinding := rbacv1.ClusterRoleBinding{
			TypeMeta: metav1.TypeMeta{
				Kind:       "ClusterRoleBinding",
				APIVersion: "rbac.authorization.k8s.io/v1",
			},
			ObjectMeta: metav1.ObjectMeta{Name: roleName},
			RoleRef: rbacv1.RoleRef{
				APIGroup: "rbac.authorization.k8s.io",
				Kind:     "ClusterRole",
				Name:     roleName,
			},
			Subjects: []rbacv1.Subject{serviceAccountSubject},
		}
		clusterRoleBindingYAMLBytes, marshalErr := yaml.Marshal(clusterRoleBinding)
		if marshalErr != nil {
			return "", "", fmt.Errorf("marshal cluster role binding: %w", marshalErr)
		}
		manifests = append(manifests, clusterRoleYAML, string(clusterRoleBindingYAMLBytes))
	}

	if len(namespaceRules) > 0 {
		role := rbacv1.Role{
			TypeMeta: metav1.TypeMeta{
				Kind:       "Role",
				APIVersion: "rbac.authorization.k8s.io/v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      roleName,
				Namespace: namespace,
			},
			Rules: namespaceRules,
		}
		roleYAMLBytes, marshalErr := yaml.Marshal(role)
		if marshalErr != nil {
			return "", "", fmt.Errorf("marshal role: %w", marshalErr)
		}
		roleBinding := rbacv1.RoleBinding{
			TypeMeta: metav1.TypeMeta{
				Kind:       "RoleBinding",
				APIVersion: "rbac.authorization.k8s.io/v1",
			},
			ObjectMeta: metav1.ObjectMeta{
				Name:      roleName,
				Namespace: namespace,
			},
			RoleRef: rbacv1.RoleRef{
				APIGroup: "rbac.authorization.k8s.io",
				Kind:     "Role",
				Name:     roleName,
			},
			Subjects: []rbacv1.Subject{serviceAccountSubject},
		}
		roleBindingYAMLBytes, marshalErr := yaml.Marshal(roleBinding)
		if marshalErr != nil {
			return "", "", fmt.Errorf("marshal role binding: %w", marshalErr)
		}
		manifests = append(manifests, string(roleYAMLBytes), string(roleBindingYAMLBytes))
	}

	bindingYAML = strings.Join(manifests, "---\n")
	if clusterRoleYAML == "" && bindingYAML != "" {
		bindingYAML = header + bindingYAML
	}
	return clusterRoleYAML, bindingYAML, nil
}
