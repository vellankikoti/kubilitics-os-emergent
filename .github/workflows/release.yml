# Release automation: build and publish artifacts on version tag
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  packages: write

# Never cancel a release mid-flight ‚Äî let it complete
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

env:
  # Keep in sync with backend-ci.yml ‚Äî includes security patch fixes
  GO_VERSION: '1.24.13'
  PLATFORMS: linux/amd64,linux/arm64

jobs:
  kcli:
    name: kcli Binaries
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: kcli/go.sum
      - name: Build kcli Linux amd64
        working-directory: kcli
        run: CGO_ENABLED=0 GOOS=linux   GOARCH=amd64 go build -ldflags="-s -w" -o ../kcli-linux-amd64   ./cmd/kcli
      - name: Build kcli Linux arm64
        working-directory: kcli
        run: CGO_ENABLED=0 GOOS=linux   GOARCH=arm64 go build -ldflags="-s -w" -o ../kcli-linux-arm64   ./cmd/kcli
      - name: Build kcli macOS amd64
        working-directory: kcli
        run: CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64 go build -ldflags="-s -w" -o ../kcli-darwin-amd64  ./cmd/kcli
      - name: Build kcli macOS arm64
        working-directory: kcli
        run: CGO_ENABLED=0 GOOS=darwin  GOARCH=arm64 go build -ldflags="-s -w" -o ../kcli-darwin-arm64  ./cmd/kcli
      - name: Build kcli Windows amd64
        working-directory: kcli
        run: CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o ../kcli-windows-amd64.exe ./cmd/kcli
      - name: Make Unix binaries executable
        run: chmod +x kcli-linux-amd64 kcli-linux-arm64 kcli-darwin-amd64 kcli-darwin-arm64 || true
      - name: Upload kcli artifacts
        uses: actions/upload-artifact@v6
        with:
          name: kcli-${{ github.ref_name }}
          path: |
            kcli-linux-amd64
            kcli-linux-arm64
            kcli-darwin-amd64
            kcli-darwin-arm64
            kcli-windows-amd64.exe

  kubilitics-ai:
    name: kubilitics-ai Binaries
    runs-on: ubuntu-latest
    timeout-minutes: 20
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
            suffix: ""
          - goos: linux
            goarch: arm64
            suffix: ""
          - goos: darwin
            goarch: amd64
            suffix: ""
          - goos: darwin
            goarch: arm64
            suffix: ""
          - goos: windows
            goarch: amd64
            suffix: ".exe"
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: kubilitics-ai/go.sum
      - name: Build kubilitics-ai (${{ matrix.goos }}/${{ matrix.goarch }})
        working-directory: kubilitics-ai
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          # CGO_ENABLED=0 for cross-platform release/desktop binaries.
          # Container images use CGO_ENABLED=1 (Dockerfile) for sqlite/pty at runtime.
          CGO_ENABLED: "0"
        run: |
          mkdir -p bin
          go build -ldflags="-s -w" \
            -o bin/kubilitics-ai-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }} \
            ./cmd/server/main.go
      - name: Make binary executable (Unix)
        if: matrix.goos != 'windows'
        run: chmod +x kubilitics-ai/bin/kubilitics-ai-${{ matrix.goos }}-${{ matrix.goarch }} || true
      - name: Upload kubilitics-ai artifact (${{ matrix.goos }}-${{ matrix.goarch }})
        uses: actions/upload-artifact@v6
        with:
          name: kubilitics-ai-${{ matrix.goos }}-${{ matrix.goarch }}-${{ github.ref_name }}
          path: kubilitics-ai/bin/kubilitics-ai-${{ matrix.goos }}-${{ matrix.goarch }}${{ matrix.suffix }}

  backend:
    name: Backend Binaries
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - uses: actions/checkout@v6
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          cache-dependency-path: kubilitics-backend/go.sum
      - name: Build Linux amd64
        working-directory: kubilitics-backend
        run: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o kubilitics-backend-linux-amd64 ./cmd/server
      - name: Build Linux arm64
        working-directory: kubilitics-backend
        run: CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="-s -w" -o kubilitics-backend-linux-arm64 ./cmd/server
      - name: Upload backend artifacts
        uses: actions/upload-artifact@v6
        with:
          name: kubilitics-backend-${{ github.ref_name }}
          path: |
            kubilitics-backend/kubilitics-backend-linux-amd64
            kubilitics-backend/kubilitics-backend-linux-arm64

  docker-backend:
    name: Backend Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract and validate version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9._-]+)?$'; then
            echo "ERROR: malformed tag '$VERSION' ‚Äî expected semver e.g. 1.2.3"
            exit 1
          fi
          echo "version=$VERSION"                        >> $GITHUB_OUTPUT
          echo "major=$(echo $VERSION | cut -d. -f1)"   >> $GITHUB_OUTPUT
          echo "minor=$(echo $VERSION | cut -d. -f1-2)" >> $GITHUB_OUTPUT
      - name: Build and push backend Docker image
        uses: docker/build-push-action@v6
        with:
          # context must be repo root: Dockerfile COPYs both kubilitics-backend/ and kcli/
          context: .
          file: ./kubilitics-backend/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/kubilitics-backend:${{ steps.version.outputs.version }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-backend:${{ steps.version.outputs.minor }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-backend:${{ steps.version.outputs.major }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-backend:latest
          platforms: ${{ env.PLATFORMS }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

  docker-ai:
    name: AI Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v6
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract and validate version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9._-]+)?$'; then
            echo "ERROR: malformed tag '$VERSION' ‚Äî expected semver e.g. 1.2.3"
            exit 1
          fi
          echo "version=$VERSION"                        >> $GITHUB_OUTPUT
          echo "major=$(echo $VERSION | cut -d. -f1)"   >> $GITHUB_OUTPUT
          echo "minor=$(echo $VERSION | cut -d. -f1-2)" >> $GITHUB_OUTPUT
      - name: Build and push AI Docker image
        uses: docker/build-push-action@v6
        with:
          context: ./kubilitics-ai
          file: ./kubilitics-ai/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/kubilitics-ai:${{ steps.version.outputs.version }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-ai:${{ steps.version.outputs.minor }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-ai:${{ steps.version.outputs.major }}
            ghcr.io/${{ github.repository_owner }}/kubilitics-ai:latest
          # AI uses CGO_ENABLED=1 (sqlite/pty) ‚Äî amd64 only; arm64 requires cross-compiler
          platforms: linux/amd64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

  desktop:
    name: Desktop (${{ matrix.name }})
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            name: macos
          - os: windows-latest
            name: windows
          - os: ubuntu-latest
            name: linux
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v6
      - name: Clean build artifacts
        shell: bash
        run: |
          # Clean binaries directory to avoid stale artifacts
          if [ -d "kubilitics-desktop/src-tauri/binaries" ]; then
            rm -rf kubilitics-desktop/src-tauri/binaries/*
          fi
          mkdir -p kubilitics-desktop/src-tauri/binaries
          # Clean Tauri target directory (optional, but ensures clean builds)
          if [ -d "kubilitics-desktop/src-tauri/target/release" ]; then
            rm -rf kubilitics-desktop/src-tauri/target/release
          fi
          if [ -d "kubilitics-desktop/src-tauri/target/universal-apple-darwin" ]; then
            rm -rf kubilitics-desktop/src-tauri/target/universal-apple-darwin
          fi
          echo "‚úÖ Cleaned build artifacts"
      - name: Verify signing key secret
        shell: bash
        env:
          KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
        run: |
          if [ -z "$KEY" ]; then
            echo "‚ö†Ô∏è  TAURI_SIGNING_PRIVATE_KEY not set ‚Äî updater .sig files will NOT be generated"
            echo "    Set the secret in repo Settings ‚Üí Secrets to enable signed updates"
          else
            echo "‚úÖ Signing key present (${#KEY} chars) ‚Äî updater artifacts will be signed"
          fi
      - uses: actions/setup-node@v6
        with:
          node-version: '20'
      - uses: dtolnay/rust-toolchain@stable
        with:
          # macOS universal build requires both targets; harmless on Windows/Linux (ignored)
          targets: aarch64-apple-darwin,x86_64-apple-darwin
      - name: Cache Cargo registry and build artifacts
        uses: actions/cache@v5
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            kubilitics-desktop/src-tauri/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('kubilitics-desktop/src-tauri/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
      - name: Cache tauri-cli install
        id: cache-tauri-cli
        uses: actions/cache@v5
        with:
          path: ~/.cargo/bin/cargo-tauri
          key: ${{ runner.os }}-tauri-cli-2
      - name: Install Tauri CLI
        if: steps.cache-tauri-cli.outputs.cache-hit != 'true'
        run: cargo install tauri-cli --version ^2.0
      - name: Install deps (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libayatana-appindicator3-dev librsvg2-dev
      - name: Install frontend deps
        # The Vite/React frontend lives in kubilitics-frontend/, not kubilitics-desktop/
        working-directory: kubilitics-frontend
        run: npm ci
      - name: Build frontend
        working-directory: kubilitics-frontend
        env:
          TAURI_BUILD: "true"
        run: npm run build
      - name: Copy frontend dist for Tauri
        # tauri.conf.json frontendDist "../dist" resolves from src-tauri/ ‚Üí kubilitics-desktop/dist
        shell: bash
        run: |
          mkdir -p kubilitics-desktop/dist
          if [ ! -d "kubilitics-frontend/dist" ] || [ -z "$(ls -A kubilitics-frontend/dist 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Frontend dist directory is empty or does not exist"
            echo "Frontend build may have failed. Checking kubilitics-frontend/dist:"
            ls -la kubilitics-frontend/dist/ || echo "Directory does not exist"
            exit 1
          fi
          cp -r kubilitics-frontend/dist/. kubilitics-desktop/dist/
          echo "‚úÖ Frontend dist copied successfully"
          echo "Verifying dist contents:"
          ls -la kubilitics-desktop/dist/ | head -10
      - name: Verify frontend dist exists
        shell: bash
        run: |
          if [ ! -d "kubilitics-desktop/dist" ] || [ -z "$(ls -A kubilitics-desktop/dist 2>/dev/null)" ]; then
            echo "‚ùå ERROR: kubilitics-desktop/dist is empty or does not exist"
            echo "This is required for Tauri build (frontendDist: ../dist)"
            exit 1
          fi
          echo "‚úÖ Frontend dist verified: $(du -sh kubilitics-desktop/dist | cut -f1)"
      - uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}
          # Cache Go deps for sidecar builds (backend, kcli, ai); avoids "Dependencies file is not found" warning
          cache-dependency-path: |
            kubilitics-backend/go.sum
            kcli/go.sum
      - name: Build Go backend sidecar
        # Tauri v2 externalBin files MUST carry the platform-triple suffix
        shell: bash
        run: |
          mkdir -p kubilitics-desktop/src-tauri/binaries
          cd kubilitics-backend
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-x86_64-apple-darwin       ./cmd/server
            CGO_ENABLED=0 GOOS=darwin  GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-aarch64-apple-darwin      ./cmd/server
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-*
            # Create universal binary for universal-apple-darwin target
            lipo -create ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-x86_64-apple-darwin ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-aarch64-apple-darwin -output ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-universal-apple-darwin
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-universal-apple-darwin
          elif [ "${{ matrix.os }}" == "windows-latest" ]; then
            CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-x86_64-pc-windows-msvc.exe ./cmd/server
          else
            CGO_ENABLED=0 GOOS=linux   GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-x86_64-unknown-linux-gnu  ./cmd/server
            CGO_ENABLED=0 GOOS=linux   GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-aarch64-unknown-linux-gnu ./cmd/server
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-backend-*
          fi
      - name: Build kcli sidecar
        shell: bash
        run: |
          mkdir -p kubilitics-desktop/src-tauri/binaries
          cd kcli
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kcli-x86_64-apple-darwin       ./cmd/kcli
            CGO_ENABLED=0 GOOS=darwin  GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kcli-aarch64-apple-darwin      ./cmd/kcli
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kcli-*
            # Create universal binary for universal-apple-darwin target
            lipo -create ../kubilitics-desktop/src-tauri/binaries/kcli-x86_64-apple-darwin ../kubilitics-desktop/src-tauri/binaries/kcli-aarch64-apple-darwin -output ../kubilitics-desktop/src-tauri/binaries/kcli-universal-apple-darwin
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kcli-universal-apple-darwin
          elif [ "${{ matrix.os }}" == "windows-latest" ]; then
            CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kcli-x86_64-pc-windows-msvc.exe ./cmd/kcli
          else
            CGO_ENABLED=0 GOOS=linux   GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kcli-x86_64-unknown-linux-gnu  ./cmd/kcli
            CGO_ENABLED=0 GOOS=linux   GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kcli-aarch64-unknown-linux-gnu ./cmd/kcli
            chmod +x ../kubilitics-desktop/src-tauri/binaries/kcli-*
          fi
      - name: Build AI sidecar (optional)
        # CGO_ENABLED=0 for cross-platform desktop distribution (no sqlite at desktop layer)
        continue-on-error: true
        shell: bash
        run: |
          if [ -d "kubilitics-ai" ]; then
            mkdir -p kubilitics-desktop/src-tauri/binaries
            cd kubilitics-ai
            if [ "${{ matrix.os }}" == "macos-latest" ]; then
              CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-x86_64-apple-darwin       ./cmd/server/main.go
              CGO_ENABLED=0 GOOS=darwin  GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-aarch64-apple-darwin      ./cmd/server/main.go
              chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-*
              # Create universal binary for universal-apple-darwin target
              lipo -create ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-x86_64-apple-darwin ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-aarch64-apple-darwin -output ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-universal-apple-darwin
              chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-universal-apple-darwin
            elif [ "${{ matrix.os }}" == "windows-latest" ]; then
              CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-x86_64-pc-windows-msvc.exe ./cmd/server/main.go
            else
              CGO_ENABLED=0 GOOS=linux   GOARCH=amd64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-x86_64-unknown-linux-gnu  ./cmd/server/main.go
              CGO_ENABLED=0 GOOS=linux   GOARCH=arm64 go build -ldflags="-s -w" -o ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-aarch64-unknown-linux-gnu ./cmd/server/main.go
              chmod +x ../kubilitics-desktop/src-tauri/binaries/kubilitics-ai-*
            fi
          fi
      - name: Verify binaries exist
        shell: bash
        run: |
          echo "üîç Verifying required binaries exist..."
          BINARIES_DIR="kubilitics-desktop/src-tauri/binaries"
          
          if [ "${{ matrix.os }}" == "macos-latest" ]; then
            REQUIRED_BINS=(
              "kubilitics-backend-x86_64-apple-darwin"
              "kubilitics-backend-aarch64-apple-darwin"
              "kubilitics-backend-universal-apple-darwin"
              "kcli-x86_64-apple-darwin"
              "kcli-aarch64-apple-darwin"
              "kcli-universal-apple-darwin"
            )
            # AI binary is optional
            if [ -f "$BINARIES_DIR/kubilitics-ai-x86_64-apple-darwin" ]; then
              REQUIRED_BINS+=("kubilitics-ai-x86_64-apple-darwin" "kubilitics-ai-aarch64-apple-darwin" "kubilitics-ai-universal-apple-darwin")
            fi
          elif [ "${{ matrix.os }}" == "windows-latest" ]; then
            REQUIRED_BINS=(
              "kubilitics-backend-x86_64-pc-windows-msvc.exe"
              "kcli-x86_64-pc-windows-msvc.exe"
            )
            if [ -f "$BINARIES_DIR/kubilitics-ai-x86_64-pc-windows-msvc.exe" ]; then
              REQUIRED_BINS+=("kubilitics-ai-x86_64-pc-windows-msvc.exe")
            fi
          else
            REQUIRED_BINS=(
              "kubilitics-backend-x86_64-unknown-linux-gnu"
              "kubilitics-backend-aarch64-unknown-linux-gnu"
              "kcli-x86_64-unknown-linux-gnu"
              "kcli-aarch64-unknown-linux-gnu"
            )
            if [ -f "$BINARIES_DIR/kubilitics-ai-x86_64-unknown-linux-gnu" ]; then
              REQUIRED_BINS+=("kubilitics-ai-x86_64-unknown-linux-gnu" "kubilitics-ai-aarch64-unknown-linux-gnu")
            fi
          fi
          
          MISSING_BINS=()
          for bin in "${REQUIRED_BINS[@]}"; do
            if [ ! -f "$BINARIES_DIR/$bin" ]; then
              MISSING_BINS+=("$bin")
            else
              echo "‚úÖ Found: $bin"
            fi
          done
          
          if [ ${#MISSING_BINS[@]} -gt 0 ]; then
            echo "‚ùå ERROR: Missing required binaries:"
            for bin in "${MISSING_BINS[@]}"; do
              echo "   - $bin"
            done
            echo ""
            echo "Available binaries in $BINARIES_DIR:"
            ls -lh "$BINARIES_DIR" || echo "Directory is empty or does not exist"
            exit 1
          fi
          
          echo "‚úÖ All required binaries verified"
      - name: Setup macOS code signing
        if: matrix.os == 'macos-latest'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -n "$APPLE_CERTIFICATE" ]; then
            echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
            security create-keychain -p "" build.keychain || true
            security default-keychain -s build.keychain
            security unlock-keychain -p "" build.keychain
            security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign || true
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
          fi
      - name: Build Tauri app (macOS universal)
        if: matrix.os == 'macos-latest'
        working-directory: kubilitics-desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_SKIP_DEVSERVER_CHECK: "true"
        # --config overrides beforeBuildCommand to "" so Tauri doesn't try to run
        # "npm run build" from kubilitics-desktop/ (which has no package.json).
        # The frontend dist was already built and copied in the previous steps.
        # APPLE_SIGNING_IDENTITY is NOT passed as an env var here ‚Äî instead we inject
        # it into the --config JSON only when the secret is set, to prevent Tauri from
        # attempting codesign with an empty identity and failing with keychain errors.
        shell: bash
        run: |
          # Verify dist exists before building
          if [ ! -d "../dist" ] || [ -z "$(ls -A ../dist 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Frontend dist not found at ../dist"
            exit 1
          fi
          # Verify binaries exist
          if [ ! -d "binaries" ] || [ -z "$(ls -A binaries 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Binaries directory is empty"
            exit 1
          fi
          echo "‚úÖ Pre-build checks passed"

          # Only inject signingIdentity when APPLE_CERTIFICATE secret is set ‚Äî
          # passing an empty string causes codesign to fail with "keychain item not found".
          # tauri.conf.json beforeBuildCommand is already "" so no override needed there.
          if [ -n "${{ secrets.APPLE_CERTIFICATE }}" ]; then
            CONFIG='{"bundle":{"macOS":{"signingIdentity":"${{ secrets.APPLE_SIGNING_IDENTITY }}"}}}'
            echo "üîê Code signing enabled"
          else
            CONFIG='{"bundle":{"macOS":{"signingIdentity":null}}}'
            echo "‚ö†Ô∏è  No APPLE_CERTIFICATE secret ‚Äî building unsigned (ad-hoc) app"
          fi

          # CI=true tells bundle_dmg.sh to skip AppleScript Finder customization
          # which fails on GH Actions runners (not authorised to send Apple events).
          CI=true cargo tauri build --target universal-apple-darwin --bundles app,dmg --config "$CONFIG"
      - name: Notarize macOS app
        if: matrix.os == 'macos-latest'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        continue-on-error: true
        run: |
          if [ -n "$APPLE_ID" ] && [ -n "$APPLE_PASSWORD" ]; then
            xcrun notarytool submit kubilitics-desktop/src-tauri/target/universal-apple-darwin/release/bundle/macos/Kubilitics.app \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait || echo "Notarization skipped or failed"
            xcrun stapler staple kubilitics-desktop/src-tauri/target/universal-apple-darwin/release/bundle/macos/Kubilitics.app || true
          fi
      - name: Build Tauri app (Windows)
        if: matrix.os == 'windows-latest'
        working-directory: kubilitics-desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_SKIP_DEVSERVER_CHECK: "true"
        shell: bash
        run: |
          # Verify dist exists before building
          if [ ! -d "../dist" ] || [ -z "$(ls -A ../dist 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Frontend dist not found at ../dist"
            exit 1
          fi
          # Verify binaries exist
          if [ ! -d "binaries" ] || [ -z "$(ls -A binaries 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Binaries directory is empty"
            exit 1
          fi
          echo "‚úÖ Pre-build checks passed"
          # tauri.conf.json beforeBuildCommand is already "" ‚Äî no override needed
          cargo tauri build --target x86_64-pc-windows-msvc --bundles nsis,msi
      - name: Build Tauri app (Linux - AppImage + DEB + RPM)
        if: matrix.os == 'ubuntu-latest'
        working-directory: kubilitics-desktop/src-tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          TAURI_SKIP_DEVSERVER_CHECK: "true"
        shell: bash
        run: |
          # Verify dist exists before building
          if [ ! -d "../dist" ] || [ -z "$(ls -A ../dist 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Frontend dist not found at ../dist"
            exit 1
          fi
          # Verify binaries exist
          if [ ! -d "binaries" ] || [ -z "$(ls -A binaries 2>/dev/null)" ]; then
            echo "‚ùå ERROR: Binaries directory is empty"
            exit 1
          fi
          echo "‚úÖ Pre-build checks passed"
          # Build all three Linux package formats in a single cargo invocation
          # (avoids 3x compilation; tauri.conf.json beforeBuildCommand is already "")
          cargo tauri build --target x86_64-unknown-linux-gnu --bundles appimage,deb,rpm
      - name: Upload desktop artifacts (macOS)
        if: matrix.os == 'macos-latest'
        uses: actions/upload-artifact@v6
        with:
          name: kubilitics-desktop-${{ matrix.name }}-${{ github.ref_name }}
          # macOS Tauri universal builds output to universal-apple-darwin, not release/
          path: kubilitics-desktop/src-tauri/target/universal-apple-darwin/release/bundle/
      - name: Upload desktop artifacts (Linux)
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v6
        with:
          name: kubilitics-desktop-${{ matrix.name }}-${{ github.ref_name }}
          # Linux builds use --target x86_64-unknown-linux-gnu so output is under that target dir
          path: kubilitics-desktop/src-tauri/target/x86_64-unknown-linux-gnu/release/bundle/
      - name: Upload desktop artifacts (Windows)
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v6
        with:
          name: kubilitics-desktop-${{ matrix.name }}-${{ github.ref_name }}
          # Windows builds use --target x86_64-pc-windows-msvc so output is under that target dir
          path: kubilitics-desktop/src-tauri/target/x86_64-pc-windows-msvc/release/bundle/

  release:
    name: Create GitHub Release
    needs: [kcli, kubilitics-ai, backend, desktop, docker-backend, docker-ai]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v7
        with:
          path: artifacts

      - name: Flatten artifacts for release upload
        # download-artifact@v4 nests each artifact in its own sub-directory.
        # Only copy the final installer/binary files ‚Äî not Tauri intermediate
        # build outputs (hundreds of .so/.dll files from the bundle/ tree).
        run: |
          mkdir -p release-assets
          # Copy final installer and binary formats only
          find artifacts -type f \( \
            -name "*.dmg" \
            -o -name "*.AppImage" \
            -o -name "*.deb" \
            -o -name "*.rpm" \
            -o -name "*-setup.exe" \
            -o -name "*.msi" \
            -o -name "*.tar.gz" \
            -o -name "*.tar.gz.sig" \
            -o -name "*.dmg.sig" \
            -o -name "*.AppImage.sig" \
            -o -name "*.deb.sig" \
            -o -name "*.rpm.sig" \
            -o -name "*.exe.sig" \
            -o -name "*.msi.sig" \
            -o -name "*.nsis.zip" \
            -o -name "*.nsis.zip.sig" \
            -o -name "kubilitics-backend-linux-*" \
            -o -name "kubilitics-backend-darwin-*" \
            -o -name "kubilitics-backend-windows-*" \
            -o -name "kubilitics-ai-linux-*" \
            -o -name "kubilitics-ai-darwin-*" \
            -o -name "kubilitics-ai-windows-*" \
            -o -name "kcli-linux-*" \
            -o -name "kcli-darwin-*" \
            -o -name "kcli-windows-*" \
          \) -exec cp {} release-assets/ \;
          echo "Release assets (installer/binary files only):"
          ls -lh release-assets/
          echo "Total: $(ls release-assets/ | wc -l) files"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: release-assets/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
